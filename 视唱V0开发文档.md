#乐理项目 2017.2.25
	直系安卓：学习、成长、工作量估计  Learn once, write anywhere
	美工提供原型图、GUI、标注
	
接口文档	http://182.92.168.247:8024/api/index.html 
 
	1、乐理开分支、软键盘null、SignTop.
	2、反射运行时操作，Dagger2编译时进行依赖注入。
	3、Git提交
	     git config --global user.email "niudong@xinweitech.cn " 
	     git config --global user.name "NiuDong"  
	     git remote add origin https://git.oschina.net/NiuDong/MusicTheory227.git
	     git clone https://git.oschina.net/NiuDong/MusicTheory227.git

  		 git clone https://git.oschina.net/NiuDong/MusicKnowledge.git E:\乐理\IOS
	审核说明：
		 新版本首发，用户下载app后通过自己注册账号可以浏览学习乐理知识，方便快捷，该版本目前支持英语。
		 Test account: test@126.com password 123456
		 After the new version, users to download the app registered account can I browse through learning music knowledge, convenient and quick, this version supports English at present.test

	乐理优化：	
	     1、Home详情页面跳转Home界面时finish();
    	 2、最小化后回显界面重写onReStart()方法；
		 3、跟随系统！ 外语全是英语                                                                                                                    
		 4、三星需要特殊处理、Version Name 和VerSion Code
	     5、升级：
			Splash界面判断是第一次启动：选择上次勾选位置
		 6、升级的时候在每个平台上放最新的包！
			应用宝要使用乐固进行加密
			请在版权证明处上传测试账号和密码截图后重新提交。
			http://console.qcloud.com/legu/myapplication/index
		 7、上线的更新内容：
			用户下载app后通过自己注册账号可以浏览学习乐理知识，方便快捷，该版本目前支持简体中文、英语。

			After the new version, users to download the application to register account I can browse to learn music knowledge, convenient and quick, the current version supports English and simplified Chinese

			支持多语言语种-简体中文。
			优化中文校准。
			程序代码优化。
			
			英文
			Support multi-language language - Simplified Chinese.
			Optimize Chinese calibration.
			Program code optimization. 
	
			小米已经放置高版本的包、
			
        8、排名 https://aso100.com/
		9、亚马逊上线： 设备需要18
		   https://developer.amazon.com/application/binary/M3TTCT6WP99L0Q/new.html
		10、为了统一管理，都放置1.0.1的  版本号是2


		   漏洞解决--------上线的时候这一行代码为false   android:allowBackup="false"
		    <application
	       	 android:name=".MusicApplication"
	       	 android:allowBackup="false"
	       	 android:configChanges="locale"
	       	 android:icon="@mipmap/logo"
	       	 android:label="@string/app_name"
	       	 android:supportsRtl="true"
	      	 android:theme="@style/no_title"
	       	 tools:replace="android:allowBackup">
			 http://blog.csdn.net/hello_lnjy/article/details/54599284
	11、如何获取应用程序的版本号：

			PackageInfo packinfo = context.getPackageManager().getPackageInfo(
			context.getPackageName(), 0);
			//展示给消费者的版本号
			String version = packinfo.versionName;
			//程序内部管理的版本号
			int versioncode = packinfo.versionCode;
		注意：在一个应用程序实例中，每个 APK 的版本名必须相同(格式为 X.X.X，其中，X 为整数)。

	12、多张图片做动画
	13、反馈意见：feedback.music@xinweitech.cn  这个       乐理IOS内测   https://www.pgyer.com/yKiq
	14、解绑定个推账号！  首页数据 使用userNo
	15、第一次登陆----Login 延时2秒      如果已经登录----Main 不延时




##2017年2月6日
  	1、使用统一的公司账号集成三方平台
		用户名:open.account@xinweitech.cn
		组织单位名称:北京得它科技有限公司
		别名:data_music
  		亚楠邮箱："houyanan"<houyanan925@163.com>


  	2、使用自动适配布局
     	AutoLayoutConifg.getInstance().useDeviceSize().init(this);


	3、网络失败会走哪里？
		用帧布局
		isOpenNetwork   有网加载一布局   无网络加载另一个
		NetManager.getInstance().isOpenNetwork()
		Login界面---如果没有网络是会提示用于没有网络
		Home 主页进去时候无网络-----
		http://blog.csdn.net/u012372351/article/details/50560112
		打开设置界面
		http://blog.csdn.net/hao_m582/article/details/52463063
	4、
		接口返回数据国际化
		获取语言和键盘设置 

		如果想获取手机的当前系统语言，可以通过Locale类获取，主要方法：Locale.getDefault().getLanguage()，返回的是es或者zh；通过Locale.getDefault().getCountry()获取当前国家或地区，返回为CN或US；如果当前手机设置为中文-中国，则使用此方法返回zh-CN，同理可得到其他语言与地区的信息。
	
		private boolean isZh() {
        Locale locale = getResources().getConfiguration().locale;
        String language = locale.getLanguage();
        if (language.endsWith("zh"))
            return true;
        else
            return false;
    	}

	5、RecyClerView分组列表实现
		http://www.jianshu.com/p/be62ce21ea57
	6、LitePal 可以使用外部DB数据库文件（assets或者raw目录下数据库表）么？ 
		我试了不行   

		使用数据库框架	 compile 'org.litepal.android:core:1.5.0'
	    创建数据库Connector.getDatabase();
		List<Book> books = DataSupport.findAll(Book.class);
		遍历for (Book book: books)
		InvalidAttributesException: the version of database can not be less than 1
		
		litePal：http://www.jianshu.com/p/557682e0a9f0
		http://blog.csdn.net/u013011318/article/details/44339259 


#遇到问题：
	1、亚马逊上线驳回问题
		 Steps to Reproduce:
		 Install and launch the app.
		 Actual Result: App force closes.
 		 Expected Result: App should not force close and launch as intended.
	

###视唱项目 2017.2.28
	给自己的建议：白天做重要的事情，晚上回家梳理下当天做得事情，查漏补缺，思考并制定计划！！

	Git 勤交代码：：
	首先你要安装git，  然后到你要提交代码的根目录 鼠标右键---git push here
	1、输入自己的用户名和邮箱
	     git config --global user.email "niudong@xinweitech.cn " 
  git config --global user.email "517308295@qq.com" 
git config --global user.name "wanghoa" 
	     git config --global user.name "NiuDong"  
	2、连接远程仓库
	     git remote add origin https://git.oschina.net/NiuDong/SightSing.git
	     git clone https://git.oschina.net/NiuDong/SightSing.git
	3、记得每次先更新
		 git pull origin master 回车
	4、添加到仓库
		 git add .
	5、提交说明
		git commit -m "我是xxx，我改了注册界面"
    6、提交Push
	    git push -u origin master     然后根据提示输入用户名和密码 OK！！！
  
 		git clone https://git.oschina.net/NiuDong/ShiChang.git E:\路径

		 git remote https://git.oschina.net/xinweitechgroup/SightSing.git

git clone https://git.oschina.net/NiuDong/ShiChang.git

git clone https://git.oschina.net/xinweitechgroup/SightSing.git E:\20172yue\code


 git remote add origin https://github.com/wanghoa/FirstDemo.git
 git clone https://github.com/wanghoa/FirstDemo.git


				

	接口文档地址：
	http://182.92.168.247:3001/doc/preview.html?docId=jAark2vaWS7BjNODl6gligSWKfkQYrP5   接口文档来了

	项目模块：

	1、【Android】音符频率在android下的识别 http://www.fluidsynth.org/
	    http://www.iteye.com/topic/851459
   	2、【Android】注册、多语言的界面 			------完成UI
	3、【Android】登录、改密界面实现			------完成UI
 	4、【Android】首页的UI及自定义弧形进度条	------完成UI
	5、【Android】主页面视唱UI和实现			------完成UI
	6、【Android】用户自定义筛选条件页面		------完成UI
    7、【Android】我的收藏及其详情页			------完成UI
	8、【Android】我的页、个人资料、设置页面	------完成UI
	9、下载采用okhttpUtilks采用断点下载		------用于下载资源包的时候使用	
	10、集成支付宝支付						------用于集成应用内收费	支付
	11、视唱收藏数据存储数据库					------未完善
	12、【Android】中播放（节奏和旋律模块）midi文件,将musicxml
         转为midi,然后Android播放midi			------未完成
	13、【Android】将用户录制的音符频率与数据库对应的音符频率做比较						------正在完善中
	14、【Android】节奏和旋律UI根据最终决定（使用解析musicxml或者展示图片）展示到视唱页面	------待确定最终需求
	15、【Android】根据接口文档实现具体每个页面的具体逻辑								    ------未开始
	16、【Android】自定义视唱按下Button不通过状态的处理（已经添加相关代码）			    ------已经添加
	17、【Android】视唱页面的UI以及自定义用户自定义筛选条件						        ------还需优化细
	18、【Android】结合视唱过程中的新ui，支持动态呈现音高。								------未完成
	19、【Android】6.0运行时权限配置、危险权限动态获取提示用户					        ------已经添加
	20、【Android】应用内其他语言切换的支持（除中文外）									------未完成
	21、【Android】根据音符动态改变音符展示的速度！										------未完成

	视唱用到的技术点：

	MVP+Dagger2解耦+Retrofit+Okhttp+RxJava  <考虑> 
	1、修改AS快捷键： 双击鼠标ok
	2、使用自定义的ToolBar             setContentInsetsRelative(0, 0);   边距哦！
	3、沉浸式状态栏
	4、标签控件TabLayout+ViewPager+FragmentPageAdapter联合使用
	     android.support.v4.view.ViewPager
	5、Tinker使用 热更新
	6、Android自定义带图片的圆形进度条： 	 AroundCircleView 
	     要考虑继承progressBar或者View，最终采用图片边框加进度条的方式实现    
	     图片  进度 百分比   进度  
	     安卓网格布局间距  分割线
	     http://blog.csdn.net/xiaanming/article/details/10298163
	     http://blog.csdn.net/a10615/article/details/52658927
	7、圆形头像  Glide--tran 加载   使用头像裁剪
		一个选择框可以裁剪照片
		http://download.csdn.net/download/ydxlt/9053973
	8、StartActivityForResult()使用
	9、运行时权限配置、危险权限动态获取
	   http://blog.csdn.net/chenlinfeng772885775/article/details/53508204
	10、通知可以参考蓝牙对讲Demo（没有涉及到）
   	11、内存检测LeakCanary.install(this);
	12、屏幕朝向要做处理  （全部竖屏）
	13、安卓状态栏字体颜色的修改（手机厂商定制的状态栏字体颜色略不同）
	       小米的MIUI、魅族的Flyme https://www.zhihu.com/question/31994153
	14、巧用帧布局以及线性布局的权重、inclued
	15、Button使用注意：-style="?android:attr/borderlessButtonStyle"可以去除阴影
	    或者----将background设置为 #00000000 
	    安卓RadioButton去掉小圆圈     android:button="@null"
		RadioGroup是LinearLayout的子类！他拥有父亲的特性
		多行单选 问题解决-----http://www.jianshu.com/p/2c2a44d69f24
	16、Dialog的位置
                 http://blog.csdn.net/misly_vinky/article/details/19109517
		使用FragmentDialog 实现 提醒
		http://blog.csdn.net/lmj623565791/article/details/37815413/
		http://www.jianshu.com/p/3d045ee00880

		鸿阳 
		http://download.csdn.net/detail/lmj623565791/7638357#comment
	17、注册屏幕滑动的事件   显示触摸操作！onTouchEvent    检测手势识别器   初始化 
	18、安卓翻页动画效果、参考阅读app
	       http://download.csdn.net/detail/yaoyeyzq/4892748
	19、数据库框架取本地的数据
	20、用户视唱的时候音符是在动   全民K歌
	21、new String[]{"hello"};  解析Json-----------{}  jsonobj     []   json Array
	22、Sp保存进度，回显位置     退出不清空数据噢！
	23、onSeeBarChangeListerer()     滚动监听
	24、Activity 启动模式以及自定义控件保存状态
	       LaunchMode---巧用finish();
	       singleTop：多个实例    在栈顶 那么复用，走onNewIntent    
	       singleTask：唯一是咧   移除在自己之上的所有Activity
	25、
	 	 app:tabIndicatorColor="@color/white"      // 下方滚动的下划线颜色  
	 	 app:tabSelectedTextColor="@color/gray"     // tab被选中后，文字的颜色  
	 	 app:tabTextColor="@color/white"                      // tab默认的文字颜色  


	
	26、软键盘问题：android:windowSoftInputMode="adjustPan"
		android:screenOrientation="portrait" android:windowSoftInputMode="stateHidden"
	27、支持lambda配置
		 buildTypes {
      	  release {
          	  minifyEnabled false
          	  proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-rules.pro'
       	 	}
    		}

   	 	 compileOptions {
       	 sourceCompatibility JavaVersion.VERSION_1_8
       	 targetCompatibility JavaVersion.VERSION_1_8
   	 		}
  		 retrolambda {
       	 javaVersion JavaVersion.VERSION_1_7
 		  	}

	28、用帧布局平分6个固定的Tab，参考制定会议

	
	29、TagFlowLayout  类型选择
	    compile 'com.zhy:flowlayout-lib:1.0.3'
	    floatingsearchview   加载动画
		http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2015/0914/3448.html

		CheckBox 多选框 和 RudioGroup-RudioButton 单选框
	30、国际化抽取基类

	31、Selector使用说明

		Android:state_selected是选中
		android:state_focused是获得焦点
		android:state_pressed是点击
		android:state_enabled是设置是否响应事件,指所有事件
		Shape描边说明：
		stroke：描边 corners：圆角	padding：间隔   solid 填充
		http://blog.csdn.net/bear_huangzhen/article/details/24488337
	
		全屏显示时间
		getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_IN_SCREEN);
		getWindow().addFlags(WindowManager.LayoutParams.FLAG_LAYOUT_NO_LIMITS);


	32、获取int值
		//data.getExtras().getInt（ｓｔｒｉｎｇ）；
	33、Android:textAllCaps="false"
	34、progressDialog的使用
	35、乐理和视唱的logo大小不同！！
	    ImageView+background
	36、shadow
		http://blog.csdn.net/tworoad/article/details/8657233
	37、setOnTouchListener
		ll_sight_down_status
		ll_sight_nomal_status
		ll_right	ll_wrong
	38、
		ACTION_UP。很无语 查阅资料之后 原来只要把最后的return false 改成 true 就好了。 遂记录在此。
	39、网络框架封装<进一步完善，完善之前的不足>结合rxjava 里面的调度器 不用开线程
	40、数组和集合的区别：
	    集合长度不固定，数组长度固定；换句话说，集合是动态的，数组是静态的。
		http://blog.csdn.net/lixiang_y/article/details/54376673

		集合（list）与数组的共同点：
		1.都是存储相同的数据类型的一组数据。
		2.下标都是从0开始。
		3.默认都是从下标为0的位置开始存放。
	
		集合添加元素：list.add(int index，Type type);
		集合获取元素：list.get(int index，Type type);
		集合清空：list.clear（）;
		查找集合是否存在某个元素：list.contains("");
		集合长度：list.size();
		移除集合中元素：list.remove(int index，Type type);
		截取集合中的元素：list.subList(int index,int index);
		把集合转换为数组：list.toArray();
		把数组转换为数组：Arrays.asList( );

	ArrayList：集合以数组的方式存放数据
	LinkList：集合以链表的方式存放数据 

	




	41、

	42、RecyclerView恢复浏览位置一http://www.jianshu.com/p/f6c63a59d511
	LitePal 可以使用外部DB数据库文件（assets或者raw目录下数据库表）么？
	数据库表中的查询：

	查询 sql语句  rawQu

	1、得到数据源
	2、数据加载到适配器中
	3、给List列表设置适配器
	43、自定义ImageButton
		SubLime文本编辑
	44、增量更新：使用开源二进制文件比较工具（基于Bsdiff）、省流量，更新快。缺点是服务器生成很多差异包
	45、热修复：悄悄的把代码修改了
	46、动态加载.so、Dex、apk、 加载本来不属于自身的东西。
	47、事件传递机制
		传递事件：dispatchTouchEvent();  Activity----ViewGroup----View
		处理事件：OnTouchEvent();  Acticvity---ViewGroup----View  改方法的返回值提供给dispatchEvent的返回值 
		onInterceptTouchEvent();  ViewGroup  拦截事件
	48、okhttp的缺点---回调方法都在子线程，需要结合Handler进行使用。
	49、使用Gson将json转化为数据模型  new Gson       gson.fromJson(response,User.class);
	50、TabPagerIndicator的使用
	51、手势识别	http://www.jianshu.com/p/5aeaff6f92a7
		http://glblong.blog.51cto.com/3058613/1290645

		HorizontalScrollView
		http://blog.csdn.net/lue2009/article/details/42672209
	52、音符显示：
		每一个符号分3个部分：1、符号位  2、音符位  3：判断位（箭头位置）
		1:符号位显示
		有3个位置，这个位置根据上一个相邻的（下面显示的那个）音符决定(如果是最下面的音符，在位置1)，如果下面相邻的音符是挨着或者间隔一个位置显示，并且有升降符号，那这个的升降符的位置是上一个的位置+1（超过3变为1），不然符号位位置是1。

		http://www.2cto.com/kf/201607/522398.html
		http://blog.csdn.net/yuliyige/article/details/12655895
		默认情况下，onFling()等事件不会被捕捉到。
		可以view.setLongClickable(true);
		只有这样，view才能够处理不同于Tap（轻触）的hold（即ACTION_MOVE，或者多个ACTION_DOWN）
		onScoll是在滑动的时候触发的,onFling是在手指放开的瞬间发生的

		chd_id	25869	25872		73  74  77  78  79  82  83  84  87  88 89  25963    64    67  
		对升降符号位进行判断呐！


##遇到问题：
		1、Fragment 默认会预加载相邻的两个孩子			

		2、 <HorizontalScrollView
	        android:layout_width="match_parent"
	        android:layout_height="516px"
	        android:layout_marginLeft="22px"
	        android:layout_marginRight="22px"
	        android:fadeScrollbars="false"
	        android:orientation="horizontal"
	        android:scrollbarSize="20px"
	        android:scrollbarThumbHorizontal="@drawable/bar_style_h"
	        android:scrollbars="horizontal">


	
		3、加边框
	
		<?xml version="1.0" encoding="UTF-8"?>  
		<shape xmlns:android="http://schemas.android.com/apk/res/android" >  
		  
		    <solid android:color="#FFFFFF" />  
		  
		    <stroke  
		        android:width="1dp"  
		        android:color="#000000" />  
		  
		    <padding  
		        android:bottom="1dp"  
		        android:left="1dp"  
		        android:right="1dp"  
		        android:top="1dp" />  
		  
		</shape>  

		4、break case 穿透
##扩展

	
	onItemClick
	继承关系  官方文档  
	home 最小化   onReStart();
	处理图片 矩阵 Matrix        
	音乐后台播放--涉及到服务
	经常使用tomcat服务器
	状态保存：
	    @Override
    protected void onSaveInstanceState(Bundle outState) {
        super.onSaveInstanceState(outState);

    }

    @Override
    protected void onRestoreInstanceState(Bundle savedInstanceState) {
        super.onRestoreInstanceState(savedInstanceState);


    }

	vp.addPageChangeListener() 

	抽取Base 基类
	从本地取数据
	
	使用接口  解耦合
	自定义的recyclerView 会被很多界面使用！ 
	共同的行为  通知使用的模块去加载数据 
	
	安卓获取文件路径
		//context.getExternalFilesDir
  	 	//getExternalFilesDirs
   		//getDatabasePath


	RN---http://reactnative.cn/

 
##书写布局Xml的小技巧：
	//界面全屏    

  	getWindow().setFlags(WindowManager.LayoutParams. FLAG_FULLSCREEN , WindowManager.LayoutParams. FLAG_FULLSCREEN);

	anr  还可能是 其他的where true 循环   或者 IO读写耗时 要开线程的

	zhi人生，zhi前行 
	子线程	
	数据库 数据量很大就 需要开子线程
	musicxml 文件格式
	自定义滚动的View  http://www.cnblogs.com/baiqiantao/p/5510166.html
	滚动到最右边      http://blog.csdn.net/zabio/article/details/26689673
	
	mCheckBox.setOnCheckedChangeListener(new CompoundButton.OnCheckedChangeListener() {  
        @Override  
        public void onCheckedChanged(CompoundButton compoundButton, boolean b) {  
            if(b){  
                mBtnD.setVisibility(View.VISIBLE);  
                Timer timer=new Timer();  
                timer.schedule(new TimerTask() {  
                    @Override  
                    public void run() {  
                        mHsv.fullScroll(HorizontalScrollView.FOCUS_RIGHT);  
                    }  
                },100L);  
            }else {  
                mBtnD.setVisibility(View.GONE);  
            }  
        }  
    });  

	放置音符的技巧
	关于音程：
	自己是第二位并且有升降符号  前一个M（没有升降符号）是 那么----   flStaveWidth - (MeasureUtil.getWidth(imageView) / 2)
   	relayout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 13.5f)
  	else if (noiseData.get(1).getNote_row() - noiseData.get(0).getNote_row() == 2) {

                                                     imageView.setPadding(90, 0, 0, 0);
                                                     layout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 13.5f), flStaveheight - Dp2PxUtils.dp2px(mContext, 45), 0, 0);//上面
                                                   
                                                     //原位置不动
                                                 } else if (noiseData.get(1).getNote_row() - noiseData.get(0).getNote_row() == 3) {
                                                     imageView.setPadding(100, 0, 0, 0);
                                                     relayout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 15), flStaveheight - Dp2PxUtils.dp2px(mContext, 51), 0, 0);//上面
                                                 } else {//代表大于2好多
                                                     imageView.setPadding(60, 0, 0, 0);
                                                     relayout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 9), flStaveheight - Dp2PxUtils.dp2px(mContext, 51), 0, 0);//上面
                                                 }


##开发用到的一些技术博客：
	
	小白的成长之路
	菜鸟的成长之路
	
	gitHub  NIUDONG2015      		密码zd140804  
	公众平台：https://mp.weixin.qq.com/
	安卓3年哥们
	http://blog.csdn.net/insist_hui/article/details/51783327
	
	自定义MyIndicator 
	http://blog.csdn.net/crazy__chen/article/details/47174897
	https://github.com/NIUDONG2015   多看看别人写的代码进步会很快！！
	对native 和混合式开发 去看
	菜鸟窝 
	开源库分类：
	https://android-arsenal.com/
	recyclewView相关：
	http://www.wtoutiao.com/p/25cax3A.html    这个收藏了
	http://www.jianshu.com/p/ed15eca82fd7   Xrecycleew

	标签：
		http://blog.csdn.net/cherryeve/article/details/50226773

		http://blog.csdn.net/jdsjlzx/article/details/38129569

		http://www.open-open.com/lib/view/open1425526186540.html
	屏幕适配
	http://blog.163.com/l1_jun/blog/static/143863882015412105345736/
	Refresh
	智慧北京项目：http://192.168.3.5:8080/zhbj/
	多语言参考：
	http://www.cnblogs.com/popqq520/p/5498990.html
	计时器
	http://www.jb51.net/article/91172.htm
	分组列表：
	http://blog.csdn.net/wzlyd1/article/details/52292548

	TabLayout 
	http://blog.csdn.net/tianyaleixiaowu/article/details/50820257

	细节小技巧：
	http://blog.csdn.net/qq_35224673/article/details/52208153

	进程防杀：
	http://blog.csdn.net/mynameishuangshuai/article/details/52770129
	
	Fragment ViewPager 实现左右滑动
	http://www.jianshu.com/p/ce1d060573ba
	
	7个开源项目：
	http://mp.weixin.qq.com/s/xJtFkhEzKJGoOFQoSzqL5Q
	软键盘：
	http://blog.csdn.net/elinavampire/article/details/37539659#comments
	
	开发网站：
	https://mp.weixin.qq.com/s/-tt3IMjIRUFvU-Xw8mjFtw
	程序员：
	https://juejin.im/entry/58c5794d128fe100603b5c29/detail?utm_source=gold_browser_extension
	开发注意：
	http://www.jianshu.com/p/500f1fd13b9b

	开发常见问题：http://blog.csdn.net/a172108045/article/details/50509696


##代码部分细节：


        //获取实例  
        radioGroup=(RadioGroup)findViewById(R.id.radioGroupID);  
        femaleRadioButton=(RadioButton)findViewById(R.id.femaleGroupID);  
        maleRadioButton=(RadioButton)findViewById(R.id.maleGroupID);  
        //设置监听  
        radioGroup.setOnCheckedChangeListener(new RadioGroupListener());  
	    }  
	    //定义一个RadioGroup的OnCheckedChangeListener  
	    //RadioGroup  绑定的是RadioGroup.OnCheckedChangeListener  
	    //CheckBox    绑定的是CompoundButton.OnCheckedChangeListener 或者 view.OnClickListener  
	   
	    class RadioGroupListener implements RadioGroup.OnCheckedChangeListener{  
        @Override  
        public void onCheckedChanged(RadioGroup group, int checkedId) {  
            if (checkedId==femaleRadioButton.getId()){  
                System.out.println("选中了female!");  
            }else if (checkedId==maleRadioButton.getId()){  
                System.out.println("选中了male!");  
            }  
        }  
    }  

 权限校验 工具类

            public static void checkPermission(Activity activity) {
       		 if (Build.VERSION.SDK_INT >= 23) {
            int readPhone = activity.checkSelfPermission(Manifest.permission.READ_PHONE_STATE);
            int receiveSms = activity.checkSelfPermission(Manifest.permission.RECEIVE_SMS);
            int readSms = activity.checkSelfPermission(Manifest.permission.READ_SMS);
            int readContacts = activity.checkSelfPermission(Manifest.permission.READ_CONTACTS);
            int readSdcard = activity.checkSelfPermission(Manifest.permission.READ_EXTERNAL_STORAGE);

            int requestCode = 0;
            ArrayList<String> permissions = new ArrayList<String>();
            if (readPhone != PackageManager.PERMISSION_GRANTED) {
                requestCode |= 1 << 0;
                permissions.add(Manifest.permission.READ_PHONE_STATE);
            }
            if (receiveSms != PackageManager.PERMISSION_GRANTED) {
                requestCode |= 1 << 1;
                permissions.add(Manifest.permission.RECEIVE_SMS);
            }
            if (readSms != PackageManager.PERMISSION_GRANTED) {
                requestCode |= 1 << 2;
                permissions.add(Manifest.permission.READ_SMS);
            }
            if (readContacts != PackageManager.PERMISSION_GRANTED) {
                requestCode |= 1 << 3;
                permissions.add(Manifest.permission.READ_CONTACTS);
            }
            if (readSdcard != PackageManager.PERMISSION_GRANTED) {
                requestCode |= 1 << 4;
                permissions.add(Manifest.permission.READ_EXTERNAL_STORAGE);
            }
            if (requestCode > 0) {
                String[] permission = new String[permissions.size()];
                activity.requestPermissions(permissions.toArray(permission), requestCode);
                return;
            }
        }
    }


	
 当判断当前手机没有网络时使用

	public static void showNoNetWork(final Context context) {
		AlertDialog.Builder builder = new Builder(context);
		builder.setIcon(R.mipmap.ic_launcher)//
				.setTitle(R.string.app_name)//
				.setMessage("当前无网络").setPositiveButton("设置", new OnClickListener() {

					@Override
					public void onClick(DialogInterface dialog, int which) {
						// 跳转到系统的网络设置界面
						Intent intent = new Intent();
						intent.setClassName("com.android.settings", "com.android.settings.WirelessSettings");
						context.startActivity(intent);

					}
				}).setNegativeButton("知道了", null).show();
	}

          退出
				android.os.Process.killProcess(android.os.Process.myPid());





摘自音乐BaseFragment基类类：

	public abstract class BaseFragment extends Fragment implements OnClickListener{
	@Override
	public View onCreateView(LayoutInflater inflater, ViewGroup container,
			Bundle savedInstanceState) {
		return initView(inflater, container, savedInstanceState);
	}
	
	protected abstract View initView(LayoutInflater inflater, ViewGroup container,
			Bundle savedInstanceState);

	protected abstract void initListener();

	protected abstract void initData();

	// 可以处理一些共同按钮的点击事件
	protected abstract void processClick(View v);
	
	@Override
	public void onActivityCreated(Bundle savedInstanceState) {
		super.onActivityCreated(savedInstanceState);
		initListener();
		initData();
	}
	@Override
	public void onClick(View v) {
		processClick(v);
	}
	
	protected void enterActivity(Bundle bundle,Class<?> targetActivity){
		Intent intent = new Intent(getActivity(),targetActivity);
		if(bundle!=null){
			intent.putExtras(bundle);
		}
		getActivity().startActivity(intent);
	}
    }

圆形进度条ImageProgress

		((Button)findViewById(R.id.button1)).setOnClickListener(new OnClickListener() {
			
			@Override
			public void onClick(View v) {
				new Thread(new Runnable() {
					
					@Override
					public void run() {
						while(progress <= 100){
							progress += 3;
							
							System.out.println(progress);
							
							mRoundProgressBar1.setProgress(progress);
							mRoundProgressBar2.setProgress(progress);
							mRoundProgressBar3.setProgress(progress);
							mRoundProgressBar4.setProgress(progress);
							mRoundProgressBar5.setProgress(progress);
							
							try {
								Thread.sleep(100);
							} catch (InterruptedException e) {
								e.printStackTrace();
							}
						}
						
					}
				}).start();
			}
		});
		

更新进度条

class ProgressAnimation extends AsyncTask<Void, Integer, Void> {

		@Override
		protected Void doInBackground(Void... params) {
			for (int i = 0; i < 360; i++) {
				try {
					publishProgress(i);
					Thread.sleep(250);
				} catch (InterruptedException e) {
					e.printStackTrace();
				}
			}
			return null;
		}

		@Override
		protected void onProgressUpdate(Integer... values) {
			myp.n = values[0];
			myp.invalidate();
			super.onProgressUpdate(values);
		}
	}



	private GridView gridView;
	private SimpleAdapter adapter;
	private List<Map<String, Object>> dataList;

	@Override
	protected void onCreate(Bundle savedInstanceState) {
		super.onCreate(savedInstanceState);
		requestWindowFeature(Window.FEATURE_NO_TITLE);
		setContentView(R.layout.main);
		gridView=(GridView) findViewById(R.id.gridView);
        dataList=new ArrayList<Map<String,Object>>();
        adapter=new SimpleAdapter(this, getData(), R.layout.item, new String[]{"pic","name"}, new int[]{R.id.pic,R.id.name});
        gridView.setAdapter(adapter);
	}

	private List<Map<String, Object>> getData() {
		
		int[] drawable = { R.drawable.address_book, R.drawable.calendar,
				R.drawable.camera, R.drawable.clock, R.drawable.games_control,
				R.drawable.messenger, R.drawable.ringtone, R.drawable.settings,
				R.drawable.speech_balloon, R.drawable.weather,
				R.drawable.world, R.drawable.youtube };
		String[] iconName = { "联系人", "日历", "照相机", "时钟", "游戏", "短信", "铃声", "设置",
				"语音", "天气", "浏览器", "Youtube" };
		for (int i = 0; i < drawable.length; i++) {
			Map<String, Object> map = new HashMap<String, Object>();
			map.put("pic", drawable[i]);
			map.put("name", iconName[i]);
            dataList.add(map);
		}
		Log.i("Main", "size="+dataList.size());
		return dataList;
	}


}

	隐藏掉软键盘：
  	lv.setOnTouchListener((View v, MotionEvent event) -> {
                InputMethodManager imm = (InputMethodManager) getSystemService(Context.INPUT_METHOD_SERVICE);
               if (event.getAction() == MotionEvent.ACTION_MOVE || event.getAction() == MotionEvent.ACTION_DOWN) {
                imm.hideSoftInputFromWindow(chatEt.getWindowToken(), 0);
                 }
                return false;
               });
	导入依赖
	compile 'com.irozon.keyhide:keyhide:1.0.0'
	Activity: HideKey.initialize(this);
	Fragment: HideKey.initialize(getActivity(), view);

 <LinearLayout
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_alignParentBottom="true"
            android:layout_centerHorizontal="true"
            android:orientation="vertical">

            <ImageView
                android:id="@+id/tv_takePhoto"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:src="@mipmap/pic_camera"
                android:textColor="#000000" />

            <View
                android:layout_width="match_parent"
                android:layout_height="1dp"
                android:background="#999999" />

            <ImageView
                android:id="@+id/tv_photo"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:gravity="center"
                android:src="@mipmap/pic_photo"
                android:textColor="#000000" />

            <ImageView
                android:id="@+id/iv_cancle"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_marginBottom="10dp"
                android:layout_marginTop="10dp"
                android:gravity="center"
                android:src="@mipmap/pic_cancle"
                android:textColor="#000000" />
        </LinearLayout>


		应用宝---咋么？？      设备点
		发布 应用   test 账号 
		数据库展现出来！！


	TabLayout和ViewPager
	    //   setupViewPager(viewPager);
	   //        viewPager.setOffscreenPageLimit(viewPager.getAdapter().getCount());
 	   // 设置ViewPager的数据等
	  //        tabLayout.setupWithViewPager(viewPager);
 	   //适合很多tab
	  //        tabLayout.setTabMode(TabLayout.MODE_SCROLLABLE);
 	    //tab均分,适合少的tab
	  //        tabLayout.setTabMode(TabLayout.MODE_FIXED);
	    //tab均分,适合少的tab,TabLayout.GRAVITY_CENTER
	  //        tabLayout.setTabGravity(TabLayout.GRAVITY_FILL);

	Dialog 样式
	
	http://blog.csdn.net/u013172664/article/details/51036744
	<item name="android:windowIsFloating">false</item>
    <item name="android:windowContentOverlay">@null</item>
    <item name="android:windowSoftInputMode">stateAlwaysHidden</item>
    <item name="android:windowActionModeOverlay">true</item>
    <item name="android:windowIsTranslucent">true</item>
	创建对话框	
	http://blog.csdn.net/u013718120/article/details/52503421
http://blog.csdn.net/shangs2010/article/details/8261254

https://my.oschina.net/u/2480757/blog/532260https://my.oschina.net/u/2480757/blog/532260

http://blog.csdn.net/?aspxerrorpath=/linkdust/article/details/49707337
问题汇总
        /*
         * 将对话框的大小按屏幕大小的百分比设置
         */
//        WindowManager m = getWindowManager();
//        Display d = m.getDefaultDisplay(); // 获取屏幕宽、高用
//        WindowManager.LayoutParams p = getWindow().getAttributes(); // 获取对话框当前的参数值
//        p.height = (int) (d.getHeight() * 0.6); // 高度设置为屏幕的0.6
//        p.width = (int) (d.getWidth() * 0.65); // 宽度设置为屏幕的0.95
//        dialogWindow.setAttributes(p);
 
        dialog.show();

程序员跟熬夜没关系，跟有没有女朋友没关系。适合不适合，一是逻辑思维是否清晰、缜密；二是否有终身学习的决心；三是否有举一反三，分析和总结的能力，所谓悟性。


	<?xml version="1.0" encoding="utf-8"?>
<LinearLayout xmlns:android="http://schemas.android.com/apk/res/android"
    xmlns:app="http://schemas.android.com/apk/res-auto"
    android:layout_width="match_parent"
    android:layout_height="match_parent"
    android:background="@color/main_background"
    android:fitsSystemWindows="true"
    android:orientation="vertical">

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="240px"
        android:background="@color/statusbar_blue"
        android:orientation="vertical">

        <ImageView
            android:id="@+id/ib_more"
            android:layout_width="60px"
            android:layout_height="60px"
            android:layout_gravity="right"
            android:layout_marginRight="10px"
            android:layout_marginTop="70px"
            android:background="@drawable/header_more" />


        <FrameLayout
            android:layout_width="match_parent"
            android:layout_height="wrap_content">

            <!--      app:civ_border_color="@color/statusbar_white"
                            app:civ_border_width="7px"-->
            <View
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_gravity="bottom"
                android:background="@color/main_background" />
            <TextView
                android:id="@+id/tv_name"
                android:layout_width="match_parent"
                android:layout_height="wrap_content"
                android:layout_marginLeft="260px"
                android:layout_marginTop="35px"
                android:singleLine="true"
                android:text="乐小壳"
                android:textColor="@color/colorwhite"
                android:textSize="40px" />


            <!--     <ImageView
                     android:layout_width="190px"
                     android:layout_height="190px"
                     android:layout_marginLeft="54px"
                     android:background="@drawable/headimg_bg" />-->

            <de.hdodenhof.circleimageview.CircleImageView
                android:id="@+id/iv_head"
                android:layout_width="180px"
                android:layout_height="180px"
                android:layout_marginLeft="54px"
                android:src="@drawable/head"
                app:civ_border_color="@color/statusbar_white"
                app:civ_border_overlay="true"
                app:civ_border_width="7px"
                app:civ_fill_color="@color/translucence_background">

            </de.hdodenhof.circleimageview.CircleImageView>



        </FrameLayout>
    </LinearLayout>

    <android.support.v7.widget.RecyclerView
        android:id="@+id/recyle_mainview"
        android:layout_width="match_parent"
        android:layout_height="0px"
        android:layout_marginTop="72px"
        android:layout_weight="1"
        android:background="@color/main_background" />

    <LinearLayout
        android:layout_width="match_parent"
        android:layout_height="152px"
        android:background="@color/colorwhite">

        <LinearLayout
            android:id="@+id/ll_collect"
            android:layout_width="0px"
            android:layout_height="match_parent"
            android:layout_weight="1">

            <ImageView
                android:layout_width="50px"
                android:layout_height="50px"
                android:layout_gravity="center"
                android:layout_marginLeft="54px"
                android:src="@drawable/home_icon_sc"

                />

            <TextView
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:text="我的收藏"
                android:textColor="@color/login_reg"
                android:textSize="32px" />


        </LinearLayout>


        <LinearLayout
            android:id="@+id/ll_already_collect"
            android:layout_width="0px"
            android:layout_height="match_parent"
            android:layout_weight="1"
            android:gravity="right">

            <TextView
                android:id="@+id/tv_already_collect"
                android:layout_width="wrap_content"
                android:layout_height="wrap_content"
                android:layout_gravity="center"
                android:layout_marginRight="15px"
                android:text="已收藏10"
                android:textColor="@color/login_reg_email_hint"
                android:textSize="28px" />



            <ImageView

                android:layout_width="30px"
                android:layout_height="30px"
                android:layout_gravity="center"
                android:layout_marginRight="30px"
                android:src="@drawable/icon_next_arrow" />


        </LinearLayout>


    </LinearLayout>
</LinearLayout>


	解决方法 :

	在记录开始的 System.currentTimeMillis(); 方法中设置 start_time 方法。
	然后使用 Runnable 可以执行一个循环,直到停止记录。
	final Handler handler = new Handler();
	Runnable update_runnable = new Runnable() {
	public void run() {
	updateTextView();
	}
	};
	Then with the updateTextView() you'd do something like this:
	long duration = (int) ((System.currentTimeMillis() - start_time) / 1000);
	// ... set TextView with duration value
	handler.postDelayed(update_runnable, 1000); /

#视唱交互
	1、我把用户唱的音乐用这个库转换成频率，然后取到数据库中标准的音乐和其做比较！   
	自定义button  重写onTouchEvent
 	按下---提示时间进度  分等级更新声音大小
	状态：nomal
		 recording  录制中   收集录制
		wan_to_cancel		 处理声音


	根据不同的状态进行判断 

	CDN

	获取录音声音大小并展示 计算分贝值
	http://blog.csdn.net/greatpresident/article/details/38402147

	2、
	创建表  数据库     把db放进去    取出来   写多个方法
	3、
	取出数据库中音符的位置    填充自定义UI
	
	数据库的读与写
	http://blog.csdn.net/dsa63/article/details/16951193
	单音表   前4个
  	 
		Android ImageView 设置背景选择器selector   
	
	<ImageView
	android:id="@+id/contact_photo"
	android:layout_width="wrap_content"
	android:layout_height="wrap_content"
	android:background="@drawable/photo_selector"
	android:clickable="true" />

	必须设置 android:clickable="true" 否则不会有点击效果，另外，在ImageView中，要用background引用selector，不能用src属性

	安卓给图片加边框：
	http://blog.csdn.net/sjf0115/article/details/7269251

	android:foucsable="true"  android:clickable="true"  


	按样本数量入参数  连续出现几次   一段频率是多少 
	--10个或者20个
	
	是否被选中
	http://blog.csdn.net/qq_27650777/article/details/50569153



	发送邮件：
	try {
          Intent intent = new Intent(Intent.ACTION_SENDTO, Uri.fromParts(
         "mailto", "me@caiyao.name", null));
          startActivity(Intent.createChooser(intent, "选择邮件客户端:"));
                } catch (Exception e) {
                    e.printStackTrace();
                }

	##难点攻克：
	1、其实可以用note_id，但note_id计算不方便，就加了个note_row
	   note_raw	频率
	2、  

	  <ImageView
            android:id="@+id/iv_image"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginLeft="20px"
            android:src="@drawable/staff_treble" />

        <ImageView
            android:id="@+id/iv_image2"
            android:layout_width="wrap_content"
            android:layout_height="wrap_content"
            android:layout_marginLeft="20px"
            android:layout_marginTop="250px"
            android:src="@drawable/staff_bass" />

	3、降噪函数

	  这个06f是这秒中的第06帧

	4、在android平台需要检测特定的声音，比如一个响指或者拍一下手掌，检测到后进行一下操作
	android 录音有基频提取的，使用AudioRecord加傅里叶的一个变换可以提取
	AudioRecord，基频，声音频域，声音时域  FFT

	有人说：通过AudioRecord读取MIC传入数据,然后对数据进行转换,再来判断频率.
	
	实现思路：
	1. 通过AudioRecord类读取Mic传入的数据
	2. 对读取的数据进行快速傅立叶变换
	3. 计算出进过计算后的复数的模即为需要的
	4. 
	
	Frequency

			while (currentFrequency < 82.41) {
			currentFrequency = currentFrequency * 2;
		}
		while (currentFrequency > 164.81) {
			currentFrequency = currentFrequency * 0.5;
		}
		BigDecimal a = new BigDecimal(currentFrequency);
		BigDecimal result = a.setScale(2, RoundingMode.DOWN);
		frequencyView.setText(String.valueOf(result));
	
	
	

解决方法有两种

	1.动态生成EditText

	et1 = new EditText(this);
	builder.setView(et1);
	2. 放在另一个xml中，用inflater

	LayoutInflater inflater = LayoutInflater.from(this);  
           	View textEntryView = inflater.inflate(R.layout.test1, null);  
          	et1 = (EditText)textEntryView.findViewById(R.id.editText1);
	builder.setView(textEntryView ); 注意这里是textEntryView ，不是et1 

	点击之后处理手势滑动的逻辑

	3、切换加动画效果
	
	频率比较   取中间    离最近   	fg频率递增

	42---o  o升   43  L M H 

	安卓去除没用的频率

	版本代码

	M位置：



   if (noiseData.get(0).getNote_row() == 43) {
                                             flStave.removeAllViews();
                                             imageView.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                         } else {//自己是第二位
                                             if (noiseData.get(0).mark_id.equals("M")) {//自
                                                 if (noiseData.get(1).getNote_row() - noiseData.get(0).getNote_row() < 2) {
                                                     //移动位置   向右斜对着前一个  Y轴要变化    9---------18px
                                                     imageView.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) + Dp2PxUtils.dp2px(mContext, 8), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                                 } else {
                                                     //原位置不动  原点位置
                                                     imageView.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                                 }

                                             } else {//前一个有升降符号
                                                 if (noiseData.get(1).getNote_row() - noiseData.get(0).getNote_row() < 2) {
                                                     //移动位置100      向右斜对着前一个  Y轴要变化
                                                     imageView.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) + Dp2PxUtils.dp2px(mContext, 8), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                                 } else {
                                                     //原位置不动
                                                     imageView.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                                 }
                                             }
                                         }





flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 9)
	有升降符号的位置	
		 - Dp2PxUtils.dp2px(mContext, 9)

	H有符号位
		

      if (noiseData.get(0).getNote_row() == 43) {
                                             flStave.removeAllViews();
                                             imageView.setPadding(60, 0, 0, 0);
                                             layout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 9), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面

                                         } else {//自己是第二位
                                             if (noiseData.get(0).mark_id.equals("M")) {//自
                                                 if (noiseData.get(1).getNote_row() - noiseData.get(0).getNote_row() < 2) {
                                                     //移动位置   向右斜对着前一个  Y轴要变化    9---------18px
                                                     imageView.setPadding(70, 0, 0, 0);
                                                     layout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面

                                                 } else {
                                                     //原位置不动  原点位置
                                                     imageView.setPadding(60, 0, 0, 0);
                                                     layout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                                 }

                                             } else {//前一个有升降符号
                                                 if (noiseData.get(1).getNote_row() - noiseData.get(0).getNote_row() < 2) {
                                                     //移动位置100      向右斜对着前一个  Y轴要变化     要变宽    整体靠左
                                                     imageView.setPadding(120, 0, 0, 0);
                                                     layout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 12), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                                 } else {
                                                     //原位置不动
                                                     imageView.setPadding(60, 0, 0, 0);
                                                     layout.setPadding(flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 9), flStaveheight + Dp2PxUtils.dp2px(mContext, 13), 0, 0);//上面
                                                 }
                                             }
                                         }


# 书写五线谱音符技巧

	一个音符的位置 X 轴坐标：	flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) + Dp2PxUtils.dp2px(mContext, 1)
	升降音符的位置 X 轴坐标：	flStaveWidth - (MeasureUtil.getWidth(imageView) / 2) - Dp2PxUtils.dp2px(mContext, 9)

	1.android解析xml方式
		dom解析：
		sax解析：建议这种方式
		XmlSerializer:
		pull 基于事件解析

		Pull解析：
	public class PulPersonService {
	public List<Person> getPersons(InputStream instream) throws Exception {
	  List<Person> persons = null;
	  Person person = null;
	  XmlPullParser parser = Xml.newPullParser();//得到Pull解析器
	  parser.setInput(instream, "UTF-8");//设置下输入流的编码
	  int eventType = parser.getEventType();//得到第一个事件类型
	  while (eventType != XmlPullParser.END_DOCUMENT) {//如果事件类型不是文档结束的话则不断处理事件
	   switch (eventType) {
	   case (XmlPullParser.START_DOCUMENT)://如果是文档开始事件
	    persons = new ArrayList<Person>();创建一个person集合
	    break;
	   case (XmlPullParser.START_TAG)://如果遇到标签开始
	    String tagName = parser.getName();// 获得解析器当前元素的名称
	    if ("person".equals(tagName)) {//如果当前标签名称是<person>
	     person = new Person();//创建一个person
	     person.setId(new Integer(parser.getAttributeValue(0)));//将元素的属性值赋值给id
	    }
	    if (person != null) {//如果person已经创建完成
	     if ("name".equals(tagName))//如果当前节点标记是name
	      person.setName(new String(parser.nextText()));
	     else if ("age".equals(tagName))//如果当前元素节点标记是age
	      person.setAge(new Short(parser.nextText()));
	    }
	   break;
	   case (XmlPullParser.END_TAG)://如果遇到标签结束
	    if ("person".equals(parser.getName())) {//如果是person标签结束
	     persons.add(person);//将创建完成的person加入集合
	     person = null;//并且置空
	    }
	   break;
	   }
	   eventType=parser.next();//进入下一个事件处理
	  }
	        return persons;
	}
	第二种：

	 public List<Beauty> parse(InputStream is) throws Exception {  
	    List<Beauty> mList = null;  
	    Beauty beauty = null;  

	    // 由android.util.Xml创建一个XmlPullParser实例  
	    XmlPullParser xpp = Xml.newPullParser();  
	    // 设置输入流 并指明编码方式  
	    xpp.setInput(is,"UTF-8");  
	    // 产生第一个事件  
	    int eventType = xpp.getEventType();  

	    while (eventType != XmlPullParser.END_DOCUMENT){  
	         switch (eventType) {  
	                     // 判断当前事件是否为文档开始事件  
	                     case XmlPullParser.START_DOCUMENT:  
	                         mList = new ArrayList<Beauty>(); // 初始化books集合  
	                         break;  
	                     // 判断当前事件是否为标签元素开始事件  
	                     case XmlPullParser.START_TAG:  
	                         if (xpp.getName().equals("beauty")) { // 判断开始标签元素是否是book  
	                             beauty = new Beauty();  
	                         } else if (xpp.getName().equals("name")) {  
	                             eventType = xpp.next();//让解析器指向name属性的值  
	                             // 得到name标签的属性值，并设置beauty的name  
	                             beauty.setName(xpp.getText());  
	                         } else if (xpp.getName().equals("age")) { // 判断开始标签元素是否是book  
	                             eventType = xpp.next();//让解析器指向age属性的值  
	                             // 得到age标签的属性值，并设置beauty的age  
	                             beauty.setAge(xpp.getText());  
	                         }   
	                         break;  

	                     // 判断当前事件是否为标签元素结束事件  
	                     case XmlPullParser.END_TAG:  
	                         if (xpp.getName().equals("beauty")) { // 判断结束标签元素是否是book  
	                             mList.add(beauty); // 将book添加到books集合  
	                             beauty = null;  
	                         }  
	                         break;  
	                     }  
	                     // 进入下一个元素并触发相应事件  
	                     eventType = xpp.next();  
	                 }  
	                 return mList;  

	    }  



	在android系统中，很多资源文件中,很多都是xml格式，在android系统中解析这些xml的方式，是使用pul解析器进行解析的，它和sax解析一样（个人感觉要比sax简单点），也是采用事件驱动进行解析的，当pull解析器，开始解析之后，我们可以调用它的next（）方法，来获取下一个解析事件（就是开始文档，结束文档，开始标签，结束标签），当处于某个元素时可以调用XmlPullParser的getAttributte()方法来获取属性的值，也可调用它的nextText()获取本节点的值。
	其实以上描述，就是对整个解析步骤的一个描述，看看代码吧
		
		private List<Map<String, String>> getData() {
		  List<Map<String, String>> list = new ArrayList<Map<String, String>>();
		  XmlResourceParser xrp = getResources().getXml(R.xml.channels);
		  try {
		  // 直到文档的结尾处
		  while (xrp.getEventType() != XmlResourceParser.END_DOCUMENT) {
		   // 如果遇到了开始标签
		   if (xrp.getEventType() == XmlResourceParser.START_TAG) {
		   String tagName = xrp.getName();// 获取标签的名字
		   if (tagName.equals("item")) {
		    Map<String, String> map = new HashMap<String, String>();
		    String id = xrp.getAttributeValue(null, "id");// 通过属性名来获取属性值
		    map.put("id", id);
		    String url = xrp.getAttributeValue(1);// 通过属性索引来获取属性值
		    map.put("url", url);
		    map.put("name", xrp.nextText());
		    list.add(map);
		   }
		   }
		   xrp.next();// 获取解析下一个事件
		  }
		  } catch (XmlPullParserException e) {
		  // TODO Auto-generated catch block
		  e.printStackTrace();
		  } catch (IOException e) {
		  // TODO Auto-generated catch block
		  e.printStackTrace();
		  }
		  return list;
		}





<?xml version="1.0" encoding='UTF-8' standalone='no' ?>
<!DOCTYPE score-partwise PUBLIC "-//Recordare//DTD MusicXML 3.0 Partwise//EN" "http://www.musicxml.org/dtds/partwise.dtd">
<score-partwise version="3.0">
 <work>
  <work-title />
 </work>
 <identification>
  <rights>Copyright © </rights>
  <encoding>
   <encoding-date>2016-08-08</encoding-date>
   <encoder>John Shi</encoder>
   <software>Sibelius 8.0.0</software>
   <software>Direct export, not 
>
>
>from Dolet</software>
   <encoding-description>Sibelius / MusicXML 3.0</encoding-description>
   <supports element="print" type="yes" value="yes" attribute="new-system" />
   <supports element="print" type="yes" value="yes" attribute="new-page" />
   <supports element="accidental" type="yes" />
   <supports element="beam" type="yes" />
   <supports element="stem" type="yes" />
  </encoding>
 </identification>
 <defaults>
  <scaling>
   <millimeters>210</millimeters>
   <tenths>1200</tenths>
  </scaling>
  <page-layout>
   <page-height>1697</page-height>
   <page-width>1200</page-width>
   <page-margins type="both">
    <left-margin>72</left-margin>
    <right-margin>72</right-margin>
    <top-margin>72</top-margin>
    <bottom-margin>72</bottom-margin>
   </page-margins>
  </page-layout>
  <system-layout>
   <system-margins>
    <left-margin>67</left-margin>
    <right-margin>0</right-margin>
   </system-margins>
   <system-distance>92</system-distance>
  </system-layout>
  <appearance>
   <line-width type="stem">0.9375</line-width>
   <line-width type="beam">5</line-width>
   <line-width type="staff">0.9375</line-width>
   <line-width type="light barline">1.5625</line-width>
   <line-width type="heavy barline">5</line-width>
   <line-width type="leger">1.5625</line-width>
   <line-width type="ending">1.5625</line-width>
   <line-width type="wedge">1.25</line-width>
   <line-width type="enclosure">0.9375</line-width>
   <line-width type="tuplet bracket">1.25</line-width>
   <line-width type="bracket">5</line-width>
   <line-width type="dashes">1.5625</line-width>
   <line-width type="extend">0.9375</line-width>
   <line-width type="octave shift">1.5625</line-width>
   <line-width type="pedal">1.5625</line-width>
   <line-width type="slur middle">1.5625</line-width>
   <line-width type="slur tip">0.625</line-width>
   <line-width type="tie middle">1.5625</line-width>
   <line-width type="tie tip">0.625</line-width>
   <note-size type="cue">75</note-size>
   <note-size type="grace">60</note-size>
  </appearance>
  <music-font font-family="Opus Std" font-size="19.8425" />
  <lyric-font font-family="Plantin MT Std" font-size="11.4715" />
  <lyric-language xml:lang="en" />
 </defaults>
 <part-list>
  <part-group type="start" number="1">
   <group-symbol>brace</group-symbol>
  </part-group>
  <score-part id="P1">
   <part-name>Piano</part-name>
   <part-name-display>
    <display-text>Piano</display-text>
   </part-name-display>
   <part-abbreviation>Pno.</part-abbreviation>
   <part-abbreviation-display>
    <display-text>Pno.</display-text>
   </part-abbreviation-display>
   <score-instrument id="P1-I1">
    <instrument-name>Piano (2)</instrument-name>
    <instrument-sound>keyboard.piano.grand</instrument-sound>
    <solo />
    <virtual-instrument>
     <virtual-library>General MIDI</virtual-library>
     <virtual-name>Acoustic Piano</virtual-name>
    </virtual-instrument>
   </score-instrument>
  </score-part>
  <part-group type="stop" number="1" />
 </part-list>
 <part id="P1">
  <!--============== Part: P1, Measure: 1 ==============-->
  <measure number="1" width="315">
   <print new-page="yes">
    <system-layout>
     <system-margins>
      <left-margin>22</left-margin>
      <right-margin>0</right-margin>
     </system-margins>
     <top-system-distance>218</top-system-distance>
    </system-layout>
    <staff-layout number="2">
     <staff-distance>55</staff-distance>
    </staff-layout>
   </print>
   <attributes>
    <divisions>256</divisions>
    <key color="#000000">
     <fifths>0</fifths>
     <mode>major</mode>
    </key>
    <time color="#000000">
     <beats>6</beats>
     <beat-type>8</beat-type>
    </time>
    <staves>2</staves>
    <clef number="1" color="#000000">
     <sign>G</sign>
     <line>2</line>
    </clef>
    <clef number="2" color="#000000">
     <sign>F</sign>
     <line>4</line>
    </clef>
    <staff-details number="1" print-object="yes" />
    <staff-details number="2" print-object="yes" />
   </attributes>
   <note color="#000000" default-x="75" default-y="10">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>256</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>quarter</type>
    <stem>up</stem>
    <staff>1</staff>
   </note>
   <note color="#000000" default-x="144" default-y="10">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>256</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>quarter</type>
    <stem>up</stem>
    <staff>1</staff>
   </note>
   <note color="#000000" default-x="214" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>128</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>eighth</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">begin</beam>
   </note>
   <note color="#000000" default-x="264" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>128</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>eighth</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">end</beam>
   </note>
   <backup>
    <duration>768</duration>
   </backup>
   <note default-x="75">
    <rest />
    <duration>768</duration>
    <instrument id="P1-I1" />
    <voice>2</voice>
    <type>whole</type>
    <staff>2</staff>
   </note>
  </measure>
  <!--============== Part: P1, Measure: 2 ==============-->
  <measure number="2" width="233">
   <attributes />
   <note color="#000000" default-x="15" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>128</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>eighth</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">begin</beam>
   </note>
   <note color="#000000" default-x="65" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>128</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>eighth</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">end</beam>
   </note>
   <note color="#000000" default-x="115" default-y="10">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>512</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>half</type>
    <stem>up</stem>
    <staff>1</staff>
   </note>
   <backup>
    <duration>768</duration>
   </backup>
   <note default-x="15">
    <rest />
    <duration>768</duration>
    <instrument id="P1-I1" />
    <voice>2</voice>
    <type>whole</type>
    <staff>2</staff>
   </note>
  </measure>
  <!--============== Part: P1, Measure: 3 ==============-->
  <measure number="3" width="313">
   <attributes />
   <note color="#000000" default-x="15" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>64</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>16th</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">begin</beam>
    <beam number="2">begin</beam>
   </note>
   <note color="#000000" default-x="53" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>64</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>16th</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">continue</beam>
    <beam number="2">continue</beam>
   </note>
   <note color="#000000" default-x="92" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>64</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>16th</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">continue</beam>
    <beam number="2">continue</beam>
   </note>
   <note color="#000000" default-x="130" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>64</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>16th</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">continue</beam>
    <beam number="2">end</beam>
   </note>
   <note color="#000000" default-x="169" default-y="9">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>128</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>eighth</type>
    <stem>up</stem>
    <staff>1</staff>
    <beam number="1">end</beam>
   </note>
   <note color="#000000" default-x="219" default-y="10">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>384</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>quarter</type>
    <dot />
    <stem>up</stem>
    <staff>1</staff>
   </note>
   <backup>
    <duration>768</duration>
   </backup>
   <note default-x="15">
    <rest />
    <duration>768</duration>
    <instrument id="P1-I1" />
    <voice>2</voice>
    <type>whole</type>
    <staff>2</staff>
   </note>
  </measure>
  <!--============== Part: P1, Measure: 4 ==============-->
  <measure number="4" width="170">
   <attributes />
   <note color="#000000" default-x="15" default-y="10">
    <pitch>
     <step>A</step>
     <octave>4</octave>
    </pitch>
    <duration>768</duration>
    <instrument id="P1-I1" />
    <voice>1</voice>
    <type>half</type>
    <dot />
    <stem>up</stem>
    <staff>1</staff>
   </note>
   <barline>
    <bar-style>light-heavy</bar-style>
   </barline>
   <backup>
    <duration>768</duration>
   </backup>
   <note default-x="15">
    <rest />
    <duration>768</duration>
    <instrument id="P1-I1" />
    <voice>2</voice>
    <type>whole</type>
    <staff>2</staff>
   </note>
  </measure>
 </part>
</score-partwise>


手势识别

	
    private void registerTouchEvent(GestureDetector gestureDetector) {
        SightSingActivity.MyTouchListener myTouchListener = new SightSingActivity.MyTouchListener() {
            @Override
            public void onTouchEvent(MotionEvent event) {
                gestureDetector.onTouchEvent(event);

            }
        };
        // 将myTouchListener注册到分发列表
        ((SightSingActivity) this.getActivity()).registerMyTouchListener(myTouchListener);
    }

    private void gestureScroll() {
        GestureDetector gestureDetector = new GestureDetector(mContext, new GestureDetector.SimpleOnGestureListener() {
            // 用户按下触摸屏、快速移动后松开，由1个MotionEvent ACTION_DOWN, 多个ACTION_MOVE, 1个ACTION_UP触发
            @Override
            public boolean onFling(MotionEvent e1, MotionEvent e2, float velocityX, float velocityY) {
                if (Math.abs(e2.getRawY() - e1.getRawY()) > 200) {
                    return true;
                }
                if ((e1.getRawX() - e2.getRawX()) > 40) {
                    if (pageNum > 0 && pageNum < noiseList.size()) {
                        pageNum++;//1      31
                        preAnim(ll_noise);
                        //页数和合计数
                        loadPage(noiseList.get(pageNum - 1).note_row, noiseList.get(pageNum - 1).mark_id);
                        changeStatus();

                    }
                    return true;
                }
                if ((e2.getRawX() - e1.getRawX()) > 40) {

                    if (noiseList.size() >= pageNum && pageNum > 1) {
                        Log.d(TAG, pageNum + "");
                        pageNum--;
                        nextAnim(ll_noise);
                        loadPage(noiseList.get(pageNum - 1).note_row, noiseList.get(pageNum - 1).mark_id);
                        changeStatus();

                    }
                    return true;
                }
                return super.onFling(e1, e2, velocityX, velocityY);

            }
        });

        registerTouchEvent(gestureDetector);
    }


    加权限：

    安卓获取声音频率frequence（是double类型） 最近值   比如 int是50       声音频率frequence有50.6    60.7   80   然后可以匹配最接近的获取到50    有什么好的方法？？

    直接Math.abs(变量); 唱吧  全名 腾讯

       /*         for (int i = 0; i < noiseList.size(); i++) {
                    double fqncy_nr = noiseList.get(i).getFqncy_nr();
                    //将用户录制的音符频率和fg比较    取最近   差12都是对的
                    if (result == fqncy_nr) {
                    }

                }*/

根据曲谱去查各音调的频率和套公式得到持续时间；





   ## 精简代码，抽取并封装

    
    /**
     *
     * @param markId
     * @param currentCase
     * @param y
     * @param noiseData
     * @param bmImageH
     * @param bmImageC   //中央C和普通小音符圆圈
     * @param bmImageL
     */
    public void selectRow(String markId, int currentCase, int y, List<NoiseBean> noiseData, Bitmap bmImageH, Bitmap bmImageC, Bitmap bmImageL) {



	
##积累
	public class KeepScreenon {
	
	 private static WakeLock wl;  
     
	    /** 
	     * 保持屏幕唤醒状态（即背景灯不熄灭） 
	     * @param on 是否唤醒 
	     */  
	    @SuppressWarnings("deprecation")
		public static void keepScreenOn(Context context, boolean on) {  
	        if (on) {  
	            PowerManager pm = (PowerManager) context.getSystemService(Context.POWER_SERVICE);  
	            wl = pm.newWakeLock(PowerManager.SCREEN_BRIGHT_WAKE_LOCK | PowerManager.ON_AFTER_RELEASE, "==KeepScreenOn==");  
	            wl.acquire();  
	        }else {  
	            wl.release();  
	            wl = null;  
	        }  
	    }  
	}

 通过摇晃手机的频率来改变声音的速度
	http://www.cnblogs.com/stay/archive/2011/08/17/2141737.html

乐曲中不同的音符实质上表示的是不同频率的声音。
单片机

	作者：农羽
链接：https://www.zhihu.com/question/25908428/answer/108791101
来源：知乎
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。

while(isRecording){
                int recordingBuffer = mAudioRecord.read(buffer, 0, minBufferSize);
//                Log.e("info", String.valueOf(recordingBuffer));

                //从short变换到double
                for (int i = 0; i < FFT_SIZE && i < recordingBuffer; i++) {
                    // 除以32768.0 得到-1.0到1.0之间的数字
                    doubleFFT[i] = (double) buffer[i]/ 32768.0;
//                    Log.d("double", String.valueOf(doubleFFT[i]));
                }
                //用FFT方法处理从时域转成频域
                doubleFFT_1D.realForward(doubleFFT);


录音技巧：DialogMangager
	showRecord();
	want to cancle();松开取消
	showShort(); 时间过短
	松开手指，结束视唱


Audio整合
	1、添加权限   录音、  读写
	2、保存路径 创建文件夹
	3、prepare start   new MediaPlayer stop 	realase 
	   设置输入文件路径  音频源   音频格式 编码
	   

		realase 


Fragment 使用

     		MyFragment2 fragment2=new MyFragment2();
            FragmentManager fragmentManager = getFragmentManager();
            FragmentTransaction beginTransaction = fragmentManager.beginTransaction();
            beginTransaction.add(R.id.frame, fragment2);
            beginTransaction.addToBackStack(null);
            beginTransaction.commit();

	
原来这种也是可以的
  		for (int i = 0; i < data.size(); i++) {
            AutoLinearLayout linearLayout = new AutoLinearLayout(getActivity());
            linearLayout.setOrientation(LinearLayout.VERTICAL);
            ImageView imageView = new ImageView(getActivity());
            imageView.setImageResource(data.get(i).getImage());
            TextView textView = new TextView(getActivity());
            textView.setText(data.get(i).getText());
            linearLayout.addView(imageView);
            linearLayout.addView(textView);
            hrView.addView(linearLayout);
        }


	环信 需要自己处理线程问题
	MVP处理
		
	public class ContactPresenterImpl implements ContactPresenter {
	    private ContactView mContactView;
	    private List<String> contactList = new ArrayList<>();
	
	    public ContactPresenterImpl(ContactView contactView) {
	        mContactView = contactView;
	    }
	
	    @Override
	    public void initContacts() {
	        /**
	         * 1. 首先访问本地的缓存联系人
	         * 2. 然后开辟子线程去环信后台获取当前用户的联系人
	         * 3. 更新本地的缓存，刷新UI
	         */
	        final  String currentUser = EMClient.getInstance().getCurrentUser();
	
	        List<String> contacts = DBUtils.getContacts(currentUser);
	        contactList.clear();
	        contactList.addAll(contacts);
	        mContactView.onInitContacts(contactList);
	
	        updateContactsFromServer(currentUser);
	    }


	工厂

	public class FragmentFactory {
	
	    private static ConversationFragment sConversationFragment;
	    private static ContactFragment sContactFragment;
	    private static PluginFragment sPluginFragment;
	
	    public static BaseFragment getFragment(int position){
	        BaseFragment baseFragment = null;
	        switch (position) {
	            case 0:
	                if (sConversationFragment==null){
	                    sConversationFragment = new ConversationFragment();
	                }
	                baseFragment = sConversationFragment;
	                break;
	            case 1:
	                if (sContactFragment==null){
	                    sContactFragment = new ContactFragment();
	                }
	                baseFragment = sContactFragment;
	                break;
	            case 2:
	                if (sPluginFragment==null){
	                    sPluginFragment = new PluginFragment();
	                }
	                baseFragment = sPluginFragment;
	                break;
	        }
	        return baseFragment;
	
	    }
	
	}

选择了哪一个？
	
    @Override
    public void onTabSelected(int position) {
        /**
         * 先判断当前Fragment是否被添加到了MainActivity中
         * 如果添加了则直接显示即可
         * 如果没有添加则添加，然后显示
         */
        FragmentTransaction transaction = getSupportFragmentManager().beginTransaction();
        BaseFragment fragment = FragmentFactory.getFragment(position);
        if (!fragment.isAdded()){
            transaction.add(R.id.fl_content,fragment,""+position);
        }
        transaction.show(fragment).commit();

        tvTitle.setText(titleIds[position]);
    }

默认显示第一个

	 private void initFirstFragment() {
	        /**
	         * 如果这个Activity中已经有老（就是Activity保存的历史的状态，又恢复了）的Fragment，先全部移除
	         */
	        FragmentManager supportFragmentManager = getSupportFragmentManager();
	        FragmentTransaction fragmentTransaction = supportFragmentManager.beginTransaction();
	        for(int i=0;i<titleIds.length;i++){
	            Fragment fragment = supportFragmentManager.findFragmentByTag(i + "");
	            if (fragment!=null){
	                fragmentTransaction.remove(fragment);
	            }
	        }
	        fragmentTransaction.commit();
	
	        getSupportFragmentManager().beginTransaction().add(R.id.fl_content, FragmentFactory.getFragment(0),"0").commit();
	
	        tvTitle.setText(R.string.conversation);
	    }

静态代理和动态代理  面向接口和字节码的代理 

自定义组合控件：  wegit
	三个构造参数   第一个 new   第二个和第三个使用布局的时候

    public ContactLayout(Context context) {
        this(context,null);
    }

    public ContactLayout(Context context, AttributeSet attrs) {
        super(context, attrs);
        /**
         * 将R.layout.contact_layout添加到了当前ViewGroup中
         */
        LayoutInflater.from(context).inflate(R.layout.contact_layout, this, true);
	    从当前控件中找id
        mRecyclerView = (RecyclerView) findViewById(R.id.recyclerView);
        mTextView = (TextView) findViewById(R.id.tv_float);
        mSlideBar = (SlideBar) findViewById(R.id.slideBar);
        mSwipeRefreshLayout = (SwipeRefreshLayout) findViewById(R.id.swipeRefreshLayout);
        mSwipeRefreshLayout.setColorSchemeColors(getResources().getColor(R.color.colorAccent));
    }

联系人的Adapter
      View view = LayoutInflater.from(parent.getContext()).inflate(R.layout.list_item_contact, parent, false);
	  return data == null ? 0 : data.size();


		    private OnItemClickListener mOnItemClickListener;
    public interface OnItemClickListener {
        void onItemLongClick(String contact,int position);
        void onItemClick(String contact,int position);
    }
    public void setOnItemClickListener(OnItemClickListener onItemClickListener){
        this.mOnItemClickListener = onItemClickListener;
    }


1、定义加载数据的接口
	public interface ChatView {
	
	    void onInit(List<EMMessage> emMessageList);
	
	    void onUpdate(int size);
	}

2、ChatPresenterImpl 传入该方法
	    private ChatView mChatView;
    private List<EMMessage> mEMMessageList = new ArrayList<>();

    public ChatPresenterImpl(ChatView chatView) {
        mChatView = chatView;
    }

    /**
         * 1. 如果曾经跟contact有聊天过，那么获取最多最近的20条聊天记录，然后展示到View层
         * 2. 如果没有聊天过，返回一个空的List
         */
        updateChatData(contact);
        mChatView.onInit(mEMMessageList);



3、在Activity 里实现接口重写该方法   将数据传递出去

	   @Override
	    public void onInit(List<EMMessage> emMessageList) {
	        /**
	         * 初始化
	         * 
	         * erView
	         */
	        mRecyclerView.setLayoutManager(new LinearLayoutManager(this));
	        mChatAdapter = new ChatAdapter(emMessageList);
	        mRecyclerView.setAdapter(mChatAdapter);
	        if (emMessageList.size()!=0){
	            mRecyclerView.scrollToPosition(emMessageList.size()-1);
	        }
	    }
	
	    @Override
	    public void onUpdate(int size) {
	        mChatAdapter.notifyDataSetChanged();
	        if (size!=0){
	            mRecyclerView.smoothScrollToPosition(size-1);
	        }
	    }


多参考学习别人好的东西



录音

	        @Override
	        protected Void doInBackground(Void... arg0) {
	            try {
	                int bufferSize = AudioRecord.getMinBufferSize(sampleRate,
	                        channelConfiguration, audioEncoding);
	                if (audioRecord == null) {
	                    audioRecord = new AudioRecord(
	                            MediaRecorder.AudioSource.VOICE_RECOGNITION, sampleRate,
	                            channelConfiguration, audioEncoding, bufferSize);
	                }
	                short[] buffer = new short[blockSize];
	                double[] toTransform = new double[blockSize];
	                audioRecord.startRecording();
	
	                // RECORDS AUDIO & PERFORMS FFT
	                while (start) {
	                    //获取当前时间
	
	                    startTime = System.currentTimeMillis();
	                    long v = 0;
	                    int bufferReadResult = audioRecord.read(buffer, 0, blockSize);
	                    for (int i = 0; i < blockSize && i < bufferReadResult; i++) {
	                        toTransform[i] = (double) buffer[i] / 32768.0; // / 32768.0
	                    }
	
	                    //实时获取音量值
	
	                    for (int i = 0; i < buffer.length; i++) {
	                        v += buffer[i] * buffer[i];
	                    }
	                    // 平方和除以数据总长度，得到音量大小。
	                    double mean = v / (double) bufferReadResult;
	                    double volume = 10 * Math.log10(mean);
	
	                    int i = (new Double(volume)).intValue();
	                    Log.d(TAG, "分贝值:" + volume);
	
	
	                    ThreadUtils.runOnMainThread(new Runnable() {
	                        @Override
	                        public void run() {
	                            //实时显示声音大小
	                            if (i > 0 && i < 45) {
	                                ivSightsinging.setImageResource(R.drawable.vol_01);
	                            } else if (i >= 45 && i < 52) {
	                                ivSightsinging.setImageResource(R.drawable.vol_02);
	                            } else if (i >= 52 && i < 59) {
	                                ivSightsinging.setImageResource(R.drawable.vol_03);
	                            } else if (i >= 59 && i < 66) {
	                                ivSightsinging.setImageResource(R.drawable.vol_04);
	                            } else if (i >= 66 && i < 73) {
	                                ivSightsinging.setImageResource(R.drawable.vol_05);
	                            } else if (i >= 73 && i < 80) {
	                                ivSightsinging.setImageResource(R.drawable.vol_06);
	                            } else if (i >= 80 && i < 90) {
	                                ivSightsinging.setImageResource(R.drawable.vol_07);
	                            }
	                        }
	                    });
	                    analyzedUtil.ft(toTransform);
	                    analyzedUtil.getFrequency(toTransform, 0, 1, 2);
	                    publishProgress(toTransform);
	                }
	                audioRecord.stop();
	
	            } catch (Throwable t) {
	                t.printStackTrace();
	                Log.e("AudioRecord", "Recording Failed");
	            }
	
	
	            return null;
	        }


我在思考，遇到问题 或者这种效率低的情况该杂么办？
	



过滤做循环
	所有检测到的频率   连续好几个音 
	频率 转成音对象  通过音的几条属性判断
	去除频率低的   

	录音结束后对比
	单音的话找最长的一个，音程找2个，



	首先，先检测声音，根据频率，先生成对应的实例化的音符，然后根据检测到的一段声音数据，做筛选。

	数据放到数组中，每个实例化的音符包含音符数据，和连续音符个数
	我这是做了个while循环
	首先把里面数据连续个数最少的音符数据剔除，判断前后两个音符是否相同，相同的话，进行合并，不然继续进行循环
	直到里面的数据就剩要求个数的音符（单音1个，音程2个，三和弦3个，七和弦4个），如果单个音符满足不了一定的数量（数量代表了时长），需要删除，也就是该音符没有检测到

首先，先检测声音，根据频率，先生成对应的实例化的音符，然后根据检测到的一段声音数据，做筛选。
	在用户按下按钮（Down） ：此时会获取到多个 Frequence频率， Frequence频率需要保存么？
	在用户松开按钮（UP）:  我通过Frequence频率 查找到对应的音符 存储到Map集合中，然后对这些音进行筛选过滤
	
	如果（分贝>设定分贝值）{
	
	排除不符合条件的频率范围
   		if ((frequency < 63.5) || (chooseSexType && frequency < 32)) {//不在范围内  频率太低
		 else if ((frequency > 1139.8) || (chooseSexType && frequency > 604.8)) {//超过范围啦
	 	 else{ 符合条件的
		在数据中连续个数最少出现的音符删除
		判断前后两个音符是否相同，相同的话，进行合并，不然继续进行循环
		}
		}
	  


VPN免费群号： 511148134
	平方和除以数据总长度，得到音量大小。
	最长的音   
	
	
	将用户说的音符 频率 转化为一个特定的音符，去除杂质
	
	声音就是一连串特定频率波形（自然界中是各种频率叠加后的波形），在时域里可以理解为质点随时间的做特定频率的上下运动
	
	Android应用程序中提取音频从仪器。我使用的是快速傅立叶与Jtransforms变换方法
	
	提取音频从仪器找到一个音符

	http://www.it1352.com/105412.html



提取音频从仪器找到一个音符

		http://www.iteye.com/topic/1144759
		 
		题目描述
		 
		实现删除字符串中出现次数最少的字符，若多个字符出现次数一样，则都删除。输出删除这些单词后的字符串，字符串中其它字符保持原来的顺序。
		 
		输入描述:
		字符串只包含小写英文字母, 不考虑非法输入，输入的字符串长度小于等于20个字节。
		 
		 
		输出描述:
		删除字符串中出现次数最少的字符后的字符串。
		 

http://blog.csdn.net/sihai12345/article/details/68941526
 出现次数最多的整数 JAVA

public class Main {
    public static void main(String[] args) {
        Scanner sc = new Scanner(System.in);
        int n = sc.nextInt();
        if(n>0 && n <21){   //不会告诉你评测数据里有可能n = 0 和 n=-1
            int[] nums = new int[n];
            for (int i = 0; i < nums.length; i++) {
                nums[i] = sc.nextInt();
            }
            int now = 0;
            int max = 0;
            int ans = nums[0];  //注意这里 这里有10分 eg:5 1 2 3 4 5
            for (int i = 0; i < nums.length-1; i++) {
                if(nums[i] == nums[i+1]){
                    now++;
                    if(now > max){
                        max = now;
                        ans = nums[i];
                    }
                }else{
                    now = 0;
                }
            }
            System.out.println(ans);
        }else{
        }
    }
}



		
java中求出数组中每个元素出现的次数 

	标签： it 	分类： JAVA专区
	String [] array  =  new String {aa,bb,cc,dd}
	 
	 Map<String, Integer> map = new HashMap<String, Integer>();  
	            
	          for (String str : array)  
	          {  
	              Integer num = map.get(str);  
	              num = null == num ? 1 : num + 1;  
	              map.put(str, num);  
	          }  
	          Set set = map.entrySet();  
	          Iterator  it = set.iterator();  
	          while (it.hasNext())  
	          {  
	              java.util.Map.Entry <String, Integer> entry = (Entry<String, Integer>)it.next();  
	              System.out.println("单词 " + entry.getKey() + " 出现次数 " + entry.getValue());  
	          }  
	

	public static void main(String[] args) {
	int array[]={5, 10, 10, 5, 2, 5, 3, 5, 10, 5, 2, 5, 5, 10, 1, 5, 1};
	Arrays.sort(array);// 给数组排序
	int count=0;
	int temp=array[0];
	for(int i=0;i<array.length;i++){
	if(temp !=array[i]){
	System.out.println(temp+"出现："+count+"次");
	temp = array[i];
	count=1;
	}else{
	count++;
	}
	if(i==array.length-1){
	System.out.println(temp+"出现："+count+"次");
	}
	}
	}
 两个数组合并，去掉重复的，然后再排序   
	http://blog.csdn.net/lxl_family/article/details/46369921



	[java] view plain copy print?
public static void main(String[] args) {  
        List list = new ArrayList();  
        list.add("a");  
        list.add("b");  
        list.add("c");  
        list.add("c");  
        list.add("b");  
        list.add("b");  
          
        System.out.println("合并前：" + list);  
        list = joinList(list);  
        System.out.println("合并后：" + list);  
    }  
  
    /** 
     * 将List中相同的元素合并（即只保留相同元素中的一个） 
     * @param list 需要被合并的List 
     * @return 合并后的List 
     */  
    private static List joinList(List list){  
        List list2 = new ArrayList();  
          
        for(int i=0; i<list.size();i++){  
            Object obj = list.get(i);  
            //如果当前元素不在list2中，则添加  
            if(list2.indexOf(obj) == -1){  
                list2.add(0,obj);  
            }  
        }  
          
        //上面的结果元素顺序会与之前的相反，如果需要翻转顺序，加上下面的代码  
        //Collections.reverse(list2);//倒序list  
          
        return list2;  
    }  



Where（true）循环中的细节

	 while(i--)
 	 {
	 if(i<5)
	 {
     return; //当i=4时，退出该函数
	 }
	
	 return 的作用是退出循环体所在的函数，相当于结束该方法。


	while(i--)
	  {
	   if(i<5)
	   {
	     break; //当i=4时，退出while循环，往下执行i=i+1
	   }
	  }
	  i=i+1;
	}
	break 的作用是结束循环，跳出循环体，执行后面的程序。
	

	continue 的作用是结束此次循环，进行下一次循环； 


	视唱  资源包 接口

	double d[]=new double[100];
	double d[]=new double[]{1D, 2D, 3D};
	double d[]={1D, 2D, 3D};

HashMap存放值
	http://blog.csdn.net/zhangbingtao2011/article/details/53581823

将录制好的频率放到了数组当中

    NSMutableArray *hzArray;    //检测的声音数据    init

    NSMutableArray *notesArray; //检测之后返回的数据

	
		
数组的知识：

	String [][]a={
	    		{"1","2","3"},
	    		{"4","5","6"}
	    	};
	在讲一点数组的知识：
	26，一维数组的形式：(1),  int a[]; a = new int[5];  等同于　int a[] = new int[5];
			   (2),  int[] a; a = new int[5];  等同于  int[] a = new int[5];
	27,二维数组：int a[][] = {{1,2}, {3,4,5,6}, {7,8,9}};二维数组可看成以数组为元素的数组。
		java中多维数组的声明和初始化应按从高维到低维的顺序进行，如：
		方法（1）;
		int a[][] = new int[3][];
		a[0] = new int[2];
		a[1] = new int[4];
		a[2] = new int[3];//正确
		int t[][] = new int[][4];//非法
		方法（2）；
		int a[][] = new int[3][5];//正确，分配一个三行五列的二维数组。


	实时  按住  时候就判断  念了马上就出来    不过滤   不显示音符  对错 升降高！

	筛选还是要做的！！、

	http://blog.csdn.net/u014082714/article/details/50068357


	 log((double)N)/log((double)2) 2.

log2N
	Math.log(100)/Math.log(10); 
	表示的是100的以10为底的对数函数的值，是2 向上取整用Math.ceil(double a) 向下取整用Math.floor(double a)。
将两个集合中所有的值放到一个集合中
		List<String> list1 = new ArrayList<String>();
        list1.add("a");list1.add("b");
        List<String> list2 = Arrays.asList("c","d");
        list1.addAll(list2);

合并两个List集合。有相同的元素只存在一次
	//第一个list集合  
        List<String> list_a=new ArrayList<String>();  
        list_a.add("A");  
        list_a.add("B");  
        list_a.add("C");  
        list_a.add("D");  
        //第二个list集合  
        List<String> list_b=new ArrayList<String>();  
        list_b.add("C");  
        list_b.add("D");  
        list_b.add("E");  
        list_b.add("F");  
        list_b.add("G");  
        //把第二个list集合添加到第一个list集合中  
        list_a.addAll(list_b);  
        //新的list集合，用来放最后的结果集  
        List<String>  list_c=new ArrayList<String>();  
        //把追加到一起的list循环放入set集合中  
        Set<String> set=new HashSet<String>();  
        for (int i = 0; i < list_a.size(); i++) {  
            String str=list_a.get(i);  
            set.add(str);             
        }  
        //把set集合遍历添加在list中  
        for (Iterator<String> it = set.iterator(); it.hasNext();){  
            list_c.add(it.next());  
        }  
          

java 集合里的元素是集合
		for(int i=0;i<list.size();i++){
	　　List l = list.get(i);
	　　for(Object o:l){
	　　　　
		if(o instanceof User){User user = (User) o; System.out.println(user); } if(o instanceof Department){Department dep = (Department) o; System.out.println(dep); }
	　  }
	    }

集合嵌套：http://blog.csdn.net/euller/article/details/54232748
java如何遍历list集合数组里的每一项？
	List<Object[]> list= tBankInfoDAO.getAllName(); list打印出来是：[工商, 工商银行, 工行广西路, 建设银行, 胶南邮政银行, 农行鞍山路, 农行市北二, 农业银行, 浦发, 齐鲁银行, 税务, 潍坊, 邮政李村, 邮政威海路, 邮政银行, 招商银行, 中国银行, 中行麦凯... 展开
	解决了：
	List<Object[]> list= tBankInfoDAO.getAllName();
	
	for(int i=0;i<list.size();i++){
			System.out.println(list.get(i));
		}

	for(Object[] oa : list) {
	for(int i = 0;i < oa.length;i++) {
	//syso(oa[i]);
	}
	http://blog.csdn.net/u012746051/article/details/53787702

	JAVA集合可以存储和操作数目不固定的一组数据。
	http://blog.csdn.net/lushuaiyin/article/details/7381478/
		1    666     1 3  5  7     最小


	文档、账号   UI画出来

安卓Tablayout 设定指示器的长度
 http://www.qingpingshan.com/rjbc/az/243303.htmltextView可以自己添加下划线，下划线的长度设定为和textview一样的长度就可以了
		<!--

		        <android.support.design.widget.TabLayout
		            android:id="@+id/info_tab"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            app:tabIndicatorColor="@color/statusbar_blue"
		            app:tabSelectedTextColor="@color/statusbar_blue"
		            app:tabBackground="@color/infor_background"
		            app:tabTextColor="@color/tab_font"
		            app:tabMode="fixed"
		            app:tabTextAppearance="@style/InfoTabLayoutTextStyle"
		            android:layout_centerInParent="true">

		        </android.support.design.widget.TabLayout>
		-->

		        <com.androidkun.xtablayout.XTabLayout
		            android:id="@+id/info_tab"
		            android:layout_width="wrap_content"
		            android:layout_height="wrap_content"
		            app:xTabMode="scrollable"
		            android:layout_centerInParent="true"
		            app:xTabIndicatorColor="@color/statusbar_blue"
		            app:xTabIndicatorHeight="2dp"
		            app:xTabIndicatorWidth="28dp"
		            app:xTabSelectedTextColor="@color/statusbar_blue"
		            app:xTabTextColor="@color/tab_font"
		            app:xTabTextSize="15sp"
		            app:xTabSelectedTextSize="15sp"/>

		    </com.zhy.autolayout.AutoRelativeLayout>



		    FragmentDialog实现 

			修改光标颜色http://www.bijishequ.com/detail/317696?p=